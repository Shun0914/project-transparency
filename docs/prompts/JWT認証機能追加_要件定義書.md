# JWT認証機能追加 - 実装指示書

## プロジェクト概要

既存のProject Transparencyシステムに、ユーザー認証機能を追加する。

**現状の課題:**
- 誰でも全プロジェクトにアクセスできる
- データの所有権が不明確
- セキュリティリスクが高い

**目指す状態:**
- ユーザーごとに独立したプロジェクト管理
- 自分のデータだけにアクセス可能
- セキュアな認証基盤の確立

---

## 要件定義

### 機能要件

#### 1. ユーザー登録
- メールアドレス、パスワード、名前で登録
- メールアドレスは重複不可
- パスワードはbcryptでハッシュ化して保存
- 登録完了後、自動的にJWTトークンを発行

#### 2. ログイン
- メールアドレスとパスワードで認証
- 認証成功時、JWTトークンを発行（有効期限: 24時間）
- トークンはクライアント側（localStorage）で保管

#### 3. データの所有権管理
- プロジェクトは作成したユーザーに紐づく
- 自分が作成したプロジェクトのみ閲覧・編集可能
- 他人のプロジェクトにはアクセス不可

#### 4. 既存機能の保護
- すべてのAPI（プロジェクト、メンバー、スコア）に認証を追加
- 未ログイン状態では操作不可
- 所有権のないデータへのアクセスは403エラー

---

### 非機能要件

#### セキュリティ
- パスワードは平文保存禁止（bcrypt使用）
- JWTのSECRET_KEYは環境変数で管理
- HTTPS推奨（本番環境）
- 適切なCORS設定

#### パフォーマンス
- トークン検証はDBアクセス不要（署名検証のみ）
- user_id取得時のみDB参照
- ログイン/登録は0.5秒以内にレスポンス

#### 可用性
- トークン期限切れ時は適切なエラーメッセージ
- ログイン画面への自動リダイレクト

---

## 技術方針

### バックエンド

**認証方式:** JWT（トークンベース認証）

**理由:**
- ステートレス（サーバーが状態を持たない）
- Vercel + Render の分散環境に適している
- スケールしやすい

**パスワードハッシュ化:** bcrypt

**理由:**
- パスワード保存の業界標準
- 計算コストが高く、総当たり攻撃に強い
- saltの自動管理

**依存ライブラリ:**
- PyJWT または python-jose（JWT生成・検証）
- passlib + bcrypt（パスワードハッシュ化）

---

### フロントエンド

**トークン保存:** localStorage

**理由:**
- シンプルで実装が容易
- Next.js App Routerとの相性が良い

**認証フロー:**
1. ログイン成功 → トークンをlocalStorageに保存
2. API呼び出し → Authorization ヘッダーにトークンを付与
3. トークン期限切れ → ログイン画面にリダイレクト
4. ログアウト → localStorageからトークンを削除

---

## データベース設計

### 新規テーブル: users

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| id | INTEGER | PRIMARY KEY | ユーザーID |
| email | VARCHAR | UNIQUE, NOT NULL | メールアドレス |
| hashed_password | VARCHAR | NOT NULL | ハッシュ化されたパスワード |
| name | VARCHAR | NOT NULL | ユーザー名 |
| created_at | TIMESTAMP | DEFAULT NOW | 作成日時 |

### 既存テーブルの修正: projects

**追加カラム:**
- user_id (INTEGER, FOREIGN KEY → users.id, NOT NULL)

**リレーション:**
- projects.user_id → users.id（多対一）

---

## API設計

### 新規エンドポイント

#### POST /api/auth/register
**目的:** ユーザー登録

**リクエスト:**
```json
{
  "email": "user@example.com",
  "password": "password123",
  "name": "田中太郎"
}
```

**レスポンス（成功）:**
```json
{
  "access_token": "eyJhbGci...",
  "token_type": "bearer"
}
```

**レスポンス（失敗）:**
- 400: メールアドレスが既に登録済み
- 422: バリデーションエラー

---

#### POST /api/auth/login
**目的:** ログイン

**リクエスト:**
```json
{
  "email": "user@example.com",
  "password": "password123"
}
```

**レスポンス（成功）:**
```json
{
  "access_token": "eyJhbGci...",
  "token_type": "bearer"
}
```

**レスポンス（失敗）:**
- 401: メールアドレスまたはパスワードが間違っている

---

#### GET /api/auth/me
**目的:** 現在のユーザー情報を取得

**ヘッダー:**
```
Authorization: Bearer <token>
```

**レスポンス:**
```json
{
  "id": 1,
  "email": "user@example.com",
  "name": "田中太郎",
  "created_at": "2025-11-16T10:00:00"
}
```

---

### 既存エンドポイントの修正

**すべての既存エンドポイントに以下を追加:**

1. **Authorizationヘッダーの必須化**
   - ヘッダーがない場合: 401エラー
   - トークンが無効な場合: 401エラー
   - トークンが期限切れの場合: 401エラー

2. **データの所有権チェック**
   - プロジェクトにアクセスする際、user_idをチェック
   - 所有者でない場合: 403エラー

3. **データの自動紐付け**
   - プロジェクト作成時、current_user.idを自動設定
   - プロジェクト一覧取得時、current_user.idでフィルタリング

---

## 画面設計

### 新規画面

#### 1. ログイン画面 (/auth/login)
**要素:**
- メールアドレス入力欄
- パスワード入力欄
- ログインボタン
- 「アカウント登録はこちら」リンク

**バリデーション:**
- メールアドレス形式チェック
- パスワード未入力チェック

**エラー表示:**
- 「メールアドレスまたはパスワードが間違っています」

---

#### 2. ユーザー登録画面 (/auth/register)
**要素:**
- 名前入力欄
- メールアドレス入力欄
- パスワード入力欄
- 登録ボタン
- 「ログインはこちら」リンク

**バリデーション:**
- メールアドレス形式チェック
- パスワード8文字以上
- 名前未入力チェック

**エラー表示:**
- 「このメールアドレスは既に登録されています」

---

### 既存画面の修正

#### 全画面共通
- 未ログイン状態で画面アクセス → /auth/login にリダイレクト
- ヘッダーにログアウトボタンを追加
- ユーザー名を表示（右上など）

---

## 実装の優先順位

### Phase 1: バックエンド基盤
1. usersテーブル作成
2. Userモデル、スキーマ定義
3. パスワードハッシュ化ロジック
4. JWT生成・検証ロジック
5. 認証ミドルウェア実装

### Phase 2: 認証エンドポイント
1. POST /api/auth/register
2. POST /api/auth/login
3. GET /api/auth/me

### Phase 3: 既存API修正
1. projectsテーブルに user_id 追加
2. 全エンドポイントに認証追加
3. 所有権チェックロジック追加

### Phase 4: フロントエンド基盤
1. 認証ヘルパー関数作成
2. APIクライアント修正（Authorizationヘッダー）
3. ログイン・登録画面作成

### Phase 5: 既存画面修正
1. 認証チェック追加
2. リダイレクト処理
3. ログアウト機能
4. エラーハンドリング

### Phase 6: テスト・調整
1. 動作確認
2. エラーケースのテスト
3. UI/UX調整
---

## テストシナリオ

### 1. ユーザー登録
- ✅ 正常系: 登録成功 → トークン取得
- ✅ 異常系: 既存メールアドレス → 400エラー
- ✅ 異常系: 不正なメール形式 → 422エラー

### 2. ログイン
- ✅ 正常系: 正しい認証情報 → トークン取得
- ✅ 異常系: 間違ったパスワード → 401エラー
- ✅ 異常系: 存在しないメールアドレス → 401エラー

### 3. API認証
- ✅ 正常系: 有効なトークン → アクセス成功
- ✅ 異常系: トークンなし → 401エラー
- ✅ 異常系: 無効なトークン → 401エラー
- ✅ 異常系: 期限切れトークン → 401エラー

### 4. データ所有権
- ✅ 正常系: 自分のプロジェクト → アクセス成功
- ✅ 異常系: 他人のプロジェクト → 403エラー

### 5. ログアウト
- ✅ 正常系: localStorageからトークン削除
- ✅ 正常系: ログイン画面にリダイレクト

---

## セキュリティチェックリスト

### バックエンド
- [ ] パスワードはbcryptでハッシュ化
- [ ] SECRET_KEYは環境変数で管理
- [ ] JWTに有効期限（exp）を設定
- [ ] パスワードは平文でログに出力しない
- [ ] SQLインジェクション対策（ORMで自動対応）
- [ ] CORS設定が適切

### フロントエンド
- [ ] パスワードは入力フィールドでマスク
- [ ] トークンはlocalStorageに保存（HttpOnly Cookieも検討可）
- [ ] APIエラー時、適切なエラーメッセージ
- [ ] トークン期限切れ時、自動ログアウト

---

## 参考資料

### 理論編
- `/docs/report/06_JWT認証とセキュリティの理解.md`
  - JWT、bcrypt、認証の仕組みを詳細に解説

### 既存システム
- `/docs/report/IMPLEMENTATION_GUIDE.md`
  - 既存システムの実装ガイド
- `/design/db_design.sql`
  - データベース設計
- `/design/api_design.md`
  - API設計

---

## 実装時の注意事項

### DO（推奨）
- ✅ SECRET_KEYは必ず環境変数化
- ✅ エラーメッセージはユーザーフレンドリーに
- ✅ ログインエラーは詳細を出さない（「メールまたはパスワードが違います」）
- ✅ テストは必ずPostmanで実施
- ✅ コミット前に動作確認

### DON'T（禁止）
- ❌ パスワードを平文でDBに保存
- ❌ SECRET_KEYをコードにハードコーディング
- ❌ JWTにパスワードを含める
- ❌ エラーメッセージで「メールアドレスが存在しません」と詳細を出す
- ❌ トークンをURLパラメータに含める

---

## 完了条件

### 機能的完了
- [ ] ユーザー登録ができる
- [ ] ログインができる
- [ ] ログアウトができる
- [ ] 自分のプロジェクトのみ表示される
- [ ] 他人のプロジェクトにアクセスすると403エラー
- [ ] トークン期限切れ時、ログイン画面にリダイレクト

### 技術的完了
- [ ] 全エンドポイントに認証が実装されている
- [ ] パスワードはbcryptでハッシュ化されている
- [ ] JWTの検証が正しく動作している
- [ ] CORS設定が適切
- [ ] SECRET_KEYが環境変数化されている

### ドキュメント完了
- [ ] README.mdに認証機能の説明を追加
- [ ] API仕様書（api_design.md）を更新
- [ ] 環境変数の設定方法をドキュメント化

---

**作成日:** 2025-11-16  
**対象システム:** Project Transparency  
**実装担当:** Claude Code
