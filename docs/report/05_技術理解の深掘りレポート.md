# 技術理解の深掘りレポート

**作成日**: 2025-11-09  
**目的**: Project Transparency開発を通じて理解した技術概念の整理と復習

---

## 📋 目次

1. [デプロイ・ビルド・CI/CDの全体像](#デプロイビルドcicdの全体像)
2. [SQLAlchemyのデータベース抽象化](#sqlalchemyのデータベース抽象化)
3. [フロントエンドとバックエンドの分離](#フロントエンドとバックエンドの分離)
4. [GitHubとプロダクション環境の連携](#githubとプロダクション環境の連携)
5. [Webhookの仕組み](#webhookの仕組み)
6. [バックエンドの重要性](#バックエンドの重要性)
7. [今後の学習ロードマップ](#今後の学習ロードマップ)

---

## デプロイ・ビルド・CI/CDの全体像

### 基本概念の整理

#### ビルド（Build）

**定義:**  
人間が書いたコードを、コンピューターやブラウザが実行できる形に変換すること。

**例え:**  
料理で言う「下ごしらえ」。生の食材を調理可能な状態にする。

**具体的な処理（Next.jsの場合）:**

```bash
npm run build
```

実行される内容:
- TypeScript → JavaScript に変換
- React コンポーネント → HTML に変換
- 複数のファイル → 1つに結合（バンドル）
- コードを圧縮（minify）
- 画像を最適化

**ビルド前後の比較:**

```
ビルド前:
frontend/
├── pages/
│   ├── index.tsx    (100KB)
│   └── about.tsx    (80KB)
├── components/
│   └── Button.tsx   (50KB)
└── styles/
    └── global.css   (30KB)
合計: 260KB

ビルド後:
.next/
├── static/
│   ├── chunks/
│   │   └── main.js  (30KB) ← 圧縮済み
│   └── css/
│       └── app.css  (5KB)  ← 圧縮済み
合計: 50KB（約5倍の圧縮）
```

**ビルドの目的:**
- 高速化（圧縮・最適化）
- 互換性（古いブラウザでも動く）
- セキュリティ（ソースコードを隠す）

---

#### デプロイ（Deploy）

**定義:**  
ビルドしたコードをサーバーに配置して、ユーザーがアクセスできる状態にすること。

**例え:**  
料理を皿に盛って、テーブルに出す。お客さんが食べられる状態にする。

**ローカル vs 本番環境:**

```
ローカル環境（開発中）:
http://localhost:3000
↑ 自分のPCでだけアクセスできる

本番環境（デプロイ後）:
https://your-app.vercel.app
↑ 世界中の誰でもアクセスできる
```

**デプロイのステップ:**

1. ビルド済みファイルをサーバーにアップロード
2. サーバーを起動
3. ドメイン（URL）を設定
4. ファイアウォールやHTTPSを設定
5. 動作確認

**デプロイの種類:**

**手動デプロイ（従来の方法）:**

```bash
# 1. ローカルでビルド
npm run build

# 2. サーバーにファイルをアップロード
scp -r .next/ user@server:/var/www/

# 3. サーバーを再起動
ssh user@server "sudo systemctl restart nginx"
```

所要時間: 約30-60分

**自動デプロイ（CI/CD）:**

```bash
git push origin main
# → 自動でビルド・デプロイされる
```

所要時間: 約3-5分

---

#### CI/CD（Continuous Integration / Continuous Deployment）

**定義:**  
コードの変更を自動的にテスト・ビルド・デプロイする仕組み。

**例え:**  
料理の「自動調理器」。材料を入れたら、自動で調理してお皿に盛って出してくれる。

**CIとCDの違い:**

**CI（Continuous Integration）= 継続的インテグレーション**

コードを統合（merge）する時に、自動でテストする仕組み。

```
開発者: git push
  ↓
GitHub: コードを受け取る
  ↓
CI: 自動テスト実行
  - ユニットテスト
  - リンター（コードのチェック）
  - ビルドが通るか確認
  ↓
結果: ✅ 成功 or ❌ 失敗
```

**CD（Continuous Deployment）= 継続的デプロイ**

テストが通ったら、自動で本番環境にデプロイする仕組み。

```
CI: テスト成功 ✅
  ↓
CD: 自動デプロイ
  - ビルド
  - サーバーにアップロード
  - 本番環境で起動
  ↓
結果: 🚀 本番環境に反映
```

**CI/CDの全体フロー:**

```
開発者: コードを書く
  ↓
開発者: git push origin main
  ↓
GitHub: コードを受け取る
  ↓
Webhook: Vercel/Renderに通知
  ↓
CI: 自動テスト
  ↓
CD: 自動ビルド
  ↓
CD: 自動デプロイ
  ↓
完了: https://your-app.vercel.app が更新される
```

**従来の方法（CI/CDなし）vs CI/CDあり:**

| フェーズ | 従来の方法 | CI/CDあり |
|---------|-----------|----------|
| コード修正 | 1日 | 1日 |
| テスト | 2日（手動） | 5分（自動） |
| ビルド | 3日 | 3分（自動） |
| デプロイ | 1日 | 2分（自動） |
| 合計 | 7日 | 1日 |

**効率化率: 約7倍**

---

### 概念の比較表

| 概念 | タイミング | 目的 | 例え | 自動化できる？ |
|------|-----------|------|------|---------------|
| 開発 | コードを書く時 | 機能を作る | レシピを考える | ❌ |
| ビルド | デプロイ前 | コードを変換・最適化 | 下ごしらえ | ✅ |
| テスト | ビルド前 | バグを見つける | 味見 | ✅ |
| デプロイ | ビルド後 | 公開する | 料理を出す | ✅ |
| CI | push時 | 自動テスト | 品質チェック | ✅ |
| CD | CI成功後 | 自動デプロイ | 自動配膳 | ✅ |

---

### よくある混同と正しい理解

#### 混同1: ビルド = デプロイ？

**❌ 間違い:**  
「ビルドしたら公開される」

**✅ 正しい:**  
「ビルドしたファイルを、デプロイして公開する」

ビルドはローカルでもできる:

```bash
npm run build
# → .next/ フォルダにビルド済みファイルができる
# でも、まだ誰もアクセスできない
```

---

#### 混同2: CI/CD = デプロイ？

**❌ 間違い:**  
「CI/CDってデプロイのことでしょ？」

**✅ 正しい:**  
「CI/CDは、テスト→ビルド→デプロイの全体を自動化する仕組み」

デプロイはCI/CDの一部。

---

#### 混同3: GitHub = デプロイツール？

**❌ 間違い:**  
「GitHubにpushしたら公開される」

**✅ 正しい:**  
「GitHubにpushしたら、Webhookで通知が飛んで、Vercelがデプロイする」

GitHubはコードを保管するだけ。デプロイはVercelがやっている。

---

## SQLAlchemyのデータベース抽象化

### 基本概念

**SQLAlchemyとは:**  
Pythonのデータベースツールキット。異なるデータベース（SQLite、PostgreSQL、MySQLなど）を同じコードで扱える。

**一言で言うと:**  
「同じPythonコードで、SQLite、PostgreSQL、MySQLなど、どのデータベースでも使える仕組み」

---

### 問題: データベースごとに書き方が違う

#### SQLite（ローカル開発）の場合:

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT
);
```

#### PostgreSQL（本番環境）の場合:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255)
);
```

**違いの例:**
- SQLiteは INTEGER AUTOINCREMENT、PostgreSQLは SERIAL
- SQLiteは TEXT、PostgreSQLは VARCHAR(255)
- PostgreSQLは RETURNING という機能がある

**問題点:**  
「ローカルではSQLiteで開発して、本番ではPostgreSQLを使いたい」という時に、**SQLを2回書かないといけない**。

---

### SQLAlchemyの解決策

**SQLAlchemyを使うと、Pythonのコードを1回書くだけで、どのデータベースでも動く。**

#### モデル定義（1回だけ書く）

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String)
```

#### データベース接続（環境変数で切り替え）

**ローカル環境（SQLiteを使う）:**

```python
DATABASE_URL = "sqlite:///./app.db"
engine = create_engine(DATABASE_URL)
```

**本番環境（PostgreSQLを使う）:**

```python
DATABASE_URL = "postgresql://user:pass@host/db"
engine = create_engine(DATABASE_URL)
```

#### テーブル作成（自動で変換される）

```python
Base.metadata.create_all(bind=engine)
```

**SQLAlchemyが自動で変換:**

**SQLiteの場合、実際に実行されるSQL:**

```sql
CREATE TABLE users (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    name VARCHAR
);
```

**PostgreSQLの場合、実際に実行されるSQL:**

```sql
CREATE TABLE users (
    id SERIAL NOT NULL PRIMARY KEY,
    name VARCHAR
);
```

**重要ポイント:**  
あなたは何も変更していないのに、SQLAlchemyが自動で適切なSQLに変換してくれる。

---

### SQL方言の違いを吸収

#### SQL方言とは

データベースごとに、SQLの書き方が微妙に違う。これを「SQL方言」と呼ぶ。

**例1: 自動採番**
- SQLite: INTEGER PRIMARY KEY AUTOINCREMENT
- PostgreSQL: SERIAL PRIMARY KEY
- MySQL: INT AUTO_INCREMENT PRIMARY KEY

**例2: 文字列型**
- SQLite: TEXT
- PostgreSQL: VARCHAR, TEXT
- MySQL: VARCHAR(255)

**例3: 日付型**
- SQLite: TEXT（文字列として保存）
- PostgreSQL: TIMESTAMP
- MySQL: DATETIME

**例4: LIMIT句**
- SQLite/PostgreSQL/MySQL: SELECT * FROM users LIMIT 10;
- SQL Server: SELECT TOP 10 * FROM users;
- Oracle: SELECT * FROM users WHERE ROWNUM <= 10;

#### SQLAlchemyが「吸収」する仕組み

**あなたがPythonで書く:**

```python
query = session.query(User).limit(10)
```

**SQLAlchemyが変換:**

**SQLite/PostgreSQL/MySQLの場合:**

```sql
SELECT * FROM users LIMIT 10;
```

**SQL Serverの場合:**

```sql
SELECT TOP 10 * FROM users;
```

**Oracleの場合:**

```sql
SELECT * FROM users WHERE ROWNUM <= 10;
```

**あなたは .limit(10) と書くだけ。データベースごとの違いを気にしなくていい。**

---

### ORMレイヤー

#### ORMとは

**ORM = Object-Relational Mapping（オブジェクト関係マッピング）**

**意味:**  
「データベースのテーブル」と「Pythonのクラス」を対応させる仕組み。

**イメージ:**

**データベース側（テーブル）:**

| id | name | email |
|----|------|-------|
| 1  | Taro | taro@example.com |
| 2  | Hanako | hanako@example.com |

**Python側（オブジェクト）:**

```python
user = User(id=1, name="Taro", email="taro@example.com")
```

**ORMレイヤーが翻訳:**
- テーブルの行 ↔ Pythonのオブジェクト
- SQL文 ↔ Pythonのメソッド呼び出し

#### ORMなし（生SQL）vs ORMあり

**ORMなし（生SQL）:**

```python
user_name = "Taro"
cursor.execute("SELECT * FROM users WHERE name = ?", (user_name,))
result = cursor.fetchone()
```

👉 SQLを直接書く

**ORMあり（SQLAlchemy）:**

```python
user = session.query(User).filter(User.name == "Taro").first()
```

👉 Pythonのコードだけで完結

**裏では、SQLAlchemyが自動でSQLを生成して実行している。**

---

### Pythonのメソッド → SQL文の対応表

| Pythonで書くコード | 実際に実行されるSQL |
|------------------|-------------------|
| db.add(project) | INSERT INTO projects ... |
| db.query(Project).all() | SELECT * FROM projects |
| db.query(Project).filter(Project.id == 1) | SELECT * FROM projects WHERE id = 1 |
| db.query(Project).filter(Project.name.like("%test%")) | SELECT * FROM projects WHERE name LIKE '%test%' |
| db.query(Project).order_by(Project.created_at) | SELECT * FROM projects ORDER BY created_at |
| db.query(Project).limit(10) | SELECT * FROM projects LIMIT 10 |
| db.delete(project) | DELETE FROM projects WHERE id = ... |
| db.commit() | COMMIT; |

---

### データベース固有の設定（connect_args）

#### connect_argsとは

データベースに接続する時の「オプション設定」。

#### 具体例

**SQLiteの場合:**

```python
connect_args = {"check_same_thread": False}
```

**意味:**  
SQLiteはデフォルトで「同じスレッドからしかアクセスできない」制限がある。FastAPIは複数のリクエストを並列処理するので、この制限を外す必要がある。

**PostgreSQLの場合:**

```python
connect_args = {}
```

PostgreSQLには「同じスレッド制限」がないので、特別な設定は不要。

**MySQLの場合:**

```python
connect_args = {"charset": "utf8mb4"}
```

MySQLで日本語（絵文字含む）を扱う場合、文字コードを指定する必要がある。

---

### Project Transparencyでの実装

```python
# backend/app/database.py

SQLALCHEMY_DATABASE_URL = os.getenv(
    "DATABASE_URL", 
    "sqlite:///./project_transparency.db"
)

# Renderは "postgres://" を返すが、SQLAlchemyは "postgresql://" が必要
if SQLALCHEMY_DATABASE_URL.startswith("postgres://"):
    SQLALCHEMY_DATABASE_URL = SQLALCHEMY_DATABASE_URL.replace(
        "postgres://", "postgresql://", 1
    )

# データベースの種類を判定して設定
connect_args = {}
if SQLALCHEMY_DATABASE_URL.startswith("sqlite"):
    connect_args = {"check_same_thread": False}

# エンジンを作成
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args=connect_args)
```

**この数行で何が起こっているか:**

1️⃣ 環境変数を見る
- ローカル（環境変数なし）→ SQLiteを使う
- 本番（環境変数あり）→ PostgreSQLを使う

2️⃣ データベースの種類を判定
- SQLiteなら → check_same_thread: False を設定
- PostgreSQLなら → 特別な設定なし

3️⃣ エンジンを作成
- どちらのデータベースでも、同じ create_engine を使う

**この後のコード（routers/とか）は、SQLiteでもPostgreSQLでも全く同じ。**

---

### 抽象化のメリット

#### メリット1: メンテナンスが楽

「本番環境をPostgreSQLからMySQLに変えたい」となった時:

**抽象化なし:**  
全コードを書き直し（数百〜数千行）

**抽象化あり:**  
DATABASE_URL を変えるだけ（1行）

#### メリット2: バグが減る

**抽象化なし:**  
SQLiteとPostgreSQLで同じロジックを2回書く → 片方だけバグる可能性

**抽象化あり:**  
1回書くだけ → 両方で動く

#### メリット3: 開発が速い

**抽象化なし:**  
ローカルでPostgreSQLをセットアップ（面倒）

**抽象化あり:**  
ローカルはSQLite（セットアップ不要）、本番だけPostgreSQL

---

### まとめ

**SQLAlchemyのデータベース抽象化 = 「通訳」**

```
あなた: 「ユーザーを作って」（Python）
  ↓
SQLAlchemy: 「わかった」
  ↓
SQLite: INSERT INTO users ... （SQLite方言）
PostgreSQL: INSERT INTO users ... （PostgreSQL方言）
```

**同じPythonコードで、どのデータベースでも動く。**

**メリット:**
- コードを1回書くだけ
- 環境変数を変えるだけで切り替え可能
- データベースの違いを気にしなくていい

**Project Transparencyでは:**
- ローカル: SQLite（軽量・セットアップ不要）
- 本番: PostgreSQL（永続化・本格運用）
- コード: 全く同じ

---

## フロントエンドとバックエンドの分離

### 基本的な疑問

**なぜ分けるのか？**

技術的には分ける必要はないが、分けた方が圧倒的にメリットが大きい。

---

### パターン比較

#### パターン1: 分けない（モノリシック）

**構成:**

```
┌─────────────────────────────┐
│   1つのアプリケーション      │
│                             │
│  ┌────────────────────┐     │
│  │  フロントエンド     │     │
│  │  (HTML/JS/CSS)     │     │
│  └──────────┬─────────┘     │
│             │                │
│  ┌──────────▼─────────┐     │
│  │  バックエンド       │     │
│  │  (Python/SQL)      │     │
│  └──────────┬─────────┘     │
│             │                │
│  ┌──────────▼─────────┐     │
│  │  データベース       │     │
│  └────────────────────┘     │
│                             │
│  全部まとめて1つのサーバー   │
└─────────────────────────────┘
```

**例:** WordPress、Django（テンプレート使用）

**フロントエンドのコード（例）:**

```python
# Django の場合
def user_list(request):
    users = User.objects.all()  # 直接DBアクセス
    return render(request, 'users.html', {'users': users})
```

👉 APIを経由しない。直接データベースにアクセス。

---

#### パターン2: 分ける（今回の方法）

**構成:**

```
┌──────────────────┐              ┌──────────────────┐
│  フロントエンド   │              │  バックエンド     │
│  (Next.js)       │   HTTP/API   │  (FastAPI)       │
│                  │ ◄──────────► │                  │
│  - UI/UX         │              │  - ビジネスロジック│
│  - 表示制御      │              │  - DB接続        │
└──────────────────┘              └────────┬─────────┘
                                           │
                                  ┌────────▼─────────┐
                                  │  データベース     │
                                  │  (PostgreSQL)    │
                                  └──────────────────┘
```

**フロントエンドのコード:**

```typescript
// Next.js の場合
const response = await fetch('/api/users');
const users = await response.json();
```

**バックエンドのコード:**

```python
# FastAPI の場合
@app.get("/api/users")
def get_users(db: Session = Depends(get_db)):
    return db.query(User).all()
```

👉 APIを経由する。フロントはDBに直接アクセスしない。

---

### なぜ分けるのか（5つの理由）

#### 理由1: セキュリティ

**分けない場合（危険）:**

フロントエンドのJavaScriptからデータベースに直接接続しようとすると...

```javascript
// ブラウザで実行されるコード
const connection = new PostgreSQL({
  host: 'database.example.com',
  user: 'admin',
  password: 'super_secret_password',  // ← これが丸見え！
  database: 'myapp'
});
```

**問題:**
- ブラウザで実行されるJavaScriptは**全て見える**
- 開発者ツールで簡単に確認できる
- パスワードが盗まれる
- 誰でもデータベースに接続できてしまう

**分ける場合（安全）:**

```typescript
// フロントエンド（ブラウザ）
const response = await fetch('/api/users');
```

```python
# バックエンド（サーバー）
DATABASE_URL = os.getenv("DATABASE_URL")  # 環境変数（隠されている）
engine = create_engine(DATABASE_URL)
```

**安全な理由:**
- データベースのパスワードはサーバー側だけにある
- ブラウザからは見えない
- ユーザーはAPIを通してしかアクセスできない

---

#### 理由2: バリデーション（不正なデータを防ぐ）

**具体例: ユーザー削除機能**

**分けていない場合:**

```php
// 1つのファイル内で完結
function delete_user_page() {
    $user_id = $_GET['id'];  // ← URLから取得（危険）
    $db->query("DELETE FROM users WHERE id = $user_id");
    echo "<p>ユーザーを削除しました</p>";
}
```

**何が起こるか:**

悪意のあるユーザーがURLを手打ちで変更:

```
元のURL: https://example.com/delete_user?id=5
悪意のURL: https://example.com/delete_user?id=1
```

👉 **管理者（id=1）が削除される**

さらに悪質なパターン:

```
https://example.com/delete_user?id=1 OR 1=1
```

👉 **全ユーザーが削除される（SQLインジェクション）**

**分けている場合:**

**フロントエンド:**

```typescript
const handleDelete = async (userId: number) => {
    const response = await fetch(`/api/users/${userId}`, {
        method: 'DELETE'
    });
    if (response.ok) {
        alert('削除しました');
    }
};
```

**バックエンド:**

```python
@app.delete("/api/users/{user_id}")
def delete_user(
    user_id: int, 
    current_user: User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    # 1. ログインしているか確認
    if not current_user:
        raise HTTPException(status_code=401, detail="ログインしてください")
    
    # 2. 管理者権限があるか確認
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="権限がありません")
    
    # 3. 削除対象のユーザーを取得
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="ユーザーが見つかりません")
    
    # 4. 自分自身は削除できないようにする
    if user.id == current_user.id:
        raise HTTPException(status_code=400, detail="自分自身は削除できません")
    
    # 5. 本当に削除
    db.delete(user)
    db.commit()
    
    return {"message": "削除しました"}
```

**悪意のあるユーザーが直接APIを叩いても:**

```
DELETE /api/users/1
```

👉 バックエンドで「ログインしてる？」「管理者？」「自分じゃない？」をチェック  
👉 条件を満たさないと削除されない

---

#### 理由3: 独立性（フロントとバックの分離）

**分けない場合:**

```
フロントエンドを変更
  ↓
バックエンドも影響を受ける
  ↓
全体を作り直し
```

**分ける場合:**

```
フロントエンドを変更
  ↓
APIの仕様が同じなら、バックエンドはそのまま
  ↓
フロントだけ作り直せばOK
```

**具体例:**

**最初: Webアプリ（Next.js）**

```typescript
const response = await fetch('/api/users');
```

**後から: スマホアプリ（React Native）も追加**

```typescript
const response = await fetch('/api/users');  // 同じAPI
```

**さらに: デスクトップアプリ（Electron）も追加**

```typescript
const response = await fetch('/api/users');  // 同じAPI
```

👉 **バックエンドのAPIは1つだけ作れば、フロントは何個でも作れる**

---

#### 理由4: スケーラビリティ（規模が大きくなった時）

**分けない場合:**

```
1つのサーバーに全部詰め込む
  ↓
アクセスが増える
  ↓
サーバーが重くなる
  ↓
全部まとめて増やすしかない（コスト高）
```

**分ける場合:**

```
フロントとバックが別
  ↓
アクセスが増える
  ↓
重い部分だけスケールさせる
```

**例:**

```
フロントエンド: Vercel（CDN配信、世界中に分散）
  ↓ API呼び出し
バックエンド: Render（1台で十分）
  ↓ DB接続
データベース: PostgreSQL（1台で十分）
```

**アクセスが10倍になったら:**

```
フロントエンド: Vercel（自動でスケール、追加料金なし）
  ↓ API呼び出し
バックエンド: Render（2台に増やす）
  ↓ DB接続
データベース: PostgreSQL（1台のまま、CPUだけ強化）
```

👉 **必要な部分だけ強化できる = コスト効率がいい**

---

#### 理由5: チーム開発

**分けない場合:**

```
Aさん: フロントを修正
Bさん: バックを修正
  ↓
同じファイルを触る
  ↓
コンフリクト発生
```

**分ける場合:**

```
Aさん: フロントを修正（frontendディレクトリ）
Bさん: バックを修正（backendディレクトリ）
  ↓
別のファイル
  ↓
コンフリクトしない
```

---

### フロントエンドの役割

**フロントエンドは:**
- イベントが起こったらURLにアクセス（API呼び出し）
- レスポンスを受け取る
- 画面に表示する

**それだけ。**

**重要なポイント:**
- フロントエンドはDBに直接アクセスしない
- バックエンドのAPIを通してデータを取得
- ユーザーが完全にコントロールできる領域
- **信用してはいけない**

---

### バックエンドの役割

**バックエンドは:**
- 認証（あなたは誰？）
- 認可（それをやっていい？）
- バリデーション（データは正しい？）
- ビジネスロジック（ルールに従ってる？）
- データ整合性（DBが壊れないように）
- セキュリティ（攻撃から守る）

**バックエンドは「最後の砦」**

どんなに完璧なフロントエンドを作っても、悪意のあるユーザーは:
- HTMLを書き換える
- JavaScriptを無効化する
- 直接APIを叩く
- プログラムで自動攻撃する

**だから、バックエンドで全てチェックする必要がある。**

---

### 比較表: 分ける vs 分けない

| 攻撃パターン | 分けない場合 | 分ける場合 |
|------------|------------|-----------|
| URLパラメータ改ざん | ✗ 他人のデータが見える | ✓ バックエンドで権限チェック |
| SQLインジェクション | ✗ DB破壊される可能性 | ✓ ORMで自動エスケープ |
| XSS | ✗ スクリプト埋め込まれる | ✓ フロントで自動エスケープ |
| CSRF | ✗ 偽のリクエスト受け付ける | ✓ トークンで検証 |
| 権限昇格 | ✗ 自分を管理者にできる | ✓ バックエンドで制御 |

---

### まとめ

**フロントエンドとバックエンドを分ける理由:**

1. **セキュリティ:** DBパスワードを隠せる
2. **バリデーション:** 不正なデータを防ぐ
3. **独立性:** フロント変更してもバック影響なし
4. **スケーラビリティ:** 必要な部分だけ強化
5. **チーム開発:** コンフリクトしない

**フロントエンド:**
- 見た目とUX
- 信用できない領域

**バックエンド:**
- ロジックとセキュリティ
- 信用の要

**Project Transparencyでは:**
- フロント: Next.js（Vercel）
- バック: FastAPI（Render）
- API経由で通信

---

## GitHubとプロダクション環境の連携

### 基本構成

```
あなたのPC (ローカル)
  ↓ git push
GitHub (コード保管)
  ↓ Webhook
Vercel/Render (デプロイ)
  ↓
本番環境 (ユーザーがアクセス)
```

---

### それぞれの役割

#### GitHub

**役割:**
- コードの保管（バージョン管理）
- 変更履歴の記録
- Webhookでの通知

**やらないこと:**
- ビルド（Vercelがやる）
- デプロイ（Vercelがやる）
- サーバーの管理（Vercelがやる）

---

#### Vercel/Render

**役割:**
- Webhookを受け取る
- コードをビルド
- サーバーにデプロイ
- HTTPSの設定
- CDN配信

**やらないこと:**
- コードの保管（GitHubがやる）
- コードの編集（あなたがやる）

---

### 実際の流れ（時系列）

**T=0秒: あなたがコード修正**

```typescript
// ボタンを修正
<button onClick={handleClick} className="btn-primary">Click</button>
```

**T=10秒: git push**

```bash
git push origin main
```

**T=11秒: GitHub受け取り**

GitHub: 「pushされた」

**T=12秒: Webhook発火**

GitHub → Vercel: 「pushされたよ」（HTTP POST）

**T=13秒: Vercel受信**

Vercel: 「わかった、デプロイするね」

**T=14秒: CI開始（テスト）**

```
Vercel: npm install を実行
Vercel: リンター実行
Vercel: 「テスト通った ✅」
```

**T=30秒: CD開始（ビルド）**

```bash
npm run build
```

```
Vercel: TypeScriptをJavaScriptに変換
Vercel: ファイルを圧縮
Vercel: 「ビルド完了 ✅」
```

**T=60秒: CD続き（デプロイ）**

```
Vercel: ビルド済みファイルをCDNにアップロード
Vercel: 古いバージョンと入れ替え
Vercel: 「デプロイ完了 🚀」
```

**T=90秒: 完了通知**

あなたのメール: 「Deployment succeeded」

**T=91秒: 確認**

ブラウザで https://your-app.vercel.app にアクセス  
→ 修正が反映されている ✅

---

## Webhookの仕組み

### Webhookとは

**定義:**  
「何かイベントが起きたら、指定されたURLに通知を送る」仕組み。

**例え:**  
「電話のコールバック」

```
あなた: 「荷物が届いたら電話して」（Webhook設定）
  ↓
配達員: 荷物が届いた
  ↓
配達員: 「荷物届きましたよ」（電話 = HTTP POST）
  ↓
あなた: 「ありがとう、取りに行く」（デプロイ開始）
```

---

### 技術的な仕組み

#### Step 1: Webhook設定（初回のみ）

**Vercelの初期設定時:**

```
1. あなた: 「VercelをGitHubと連携」をクリック
   ↓
2. GitHubの画面に遷移
   ↓
3. GitHub: 「Vercelに以下の権限を与えていい？」
   - リポジトリの読み取り
   - Webhookの設定
   - デプロイステータスの表示
   ↓
4. あなた: 「承認」
   ↓
5. GitHub: Vercelに「アクセストークン」を発行
```

**GitHubのリポジトリにWebhookを登録:**

```json
POST https://api.github.com/repos/username/repo/hooks

{
  "config": {
    "url": "https://vercel.com/api/v1/integrations/deploy-hooks/xxx",
    "content_type": "json"
  },
  "events": ["push", "pull_request"]
}
```

**これが意味すること:**
- GitHubに「pushされたら教えて」とお願いしている
- GitHubは「わかった、pushされたらVercelに通知するね」と約束

---

#### Step 2: git pushしたら何が起こるか

**あなたがローカルで実行:**

```bash
git push origin main
```

**GitHub側で起こること:**

```
1. GitHub: pushを受け取る
   ↓
2. GitHub: Webhookのリストを確認
   「おっ、Vercelに通知する設定があるな」
   ↓
3. GitHub: Vercelに HTTP POSTを送信
```

**送信される内容:**

```json
POST https://vercel.com/api/v1/integrations/deploy-hooks/xxx

{
  "ref": "refs/heads/main",
  "repository": {
    "name": "project-transparency",
    "full_name": "username/project-transparency",
    "clone_url": "https://github.com/username/project-transparency.git"
  },
  "pusher": {
    "name": "username"
  },
  "commits": [
    {
      "id": "abc123...",
      "message": "Add PostgreSQL support",
      "timestamp": "2025-11-08T10:30:00Z"
    }
  ]
}
```

---

#### Step 3: Vercelが受け取ったら

**Vercelのサーバー側（概念的なコード）:**

```javascript
app.post('/api/v1/integrations/deploy-hooks/:hookId', async (req, res) => {
  const payload = req.body;
  
  // 1. Webhookを検証（本当にGitHubから？）
  if (!verifyWebhook(req)) {
    return res.status(401).send('Unauthorized');
  }
  
  // 2. デプロイジョブをキューに追加
  await deployQueue.add({
    repository: payload.repository.clone_url,
    branch: 'main',
    commit: payload.commits[0].id
  });
  
  // 3. すぐに200を返す（GitHub側を待たせない）
  res.status(200).send('Deployment queued');
  
  // 4. 非同期でデプロイ処理開始
});
```

---

#### Step 4: 実際のデプロイプロセス

**Vercelのビルドサーバーで実行:**

```bash
# 1. GitHubからコードをクローン
git clone https://github.com/username/project-transparency.git
cd project-transparency/frontend

# 2. Node.jsのバージョンを確認
# package.jsonや.node-versionを読む

# 3. 依存関係をインストール
npm install

# 4. 環境変数を注入
export NEXT_PUBLIC_API_BASE_URL=https://api.onrender.com/api

# 5. ビルド
npm run build

# 6. 成果物を確認
ls -la .next/

# 7. CDNにアップロード
# .next/ の中身を世界中のCDNサーバーに配信

# 8. デプロイ完了
# https://your-app.vercel.app を有効化
```

---

### Webhookの実体を確認する方法

**GitHubで確認:**

```
1. GitHubのリポジトリを開く
2. Settings → Webhooks
3. Vercel/RenderのWebhookが登録されているはず
```

**表示される内容:**

```
Payload URL: https://vercel.com/api/v1/integrations/deploy-hooks/xxx
Recent Deliveries:
  - 2025-11-08 10:30:15 → 200 OK (45ms)
  - 2025-11-08 09:15:32 → 200 OK (38ms)
```

**「Recent Deliveries」をクリックすると:**
- 送信されたJSONデータ
- Vercelからのレスポンス
- 処理時間

これで「実際に通信している」のが見える。

---

### Webhookの双方向性

**間違った理解:**
「GitHubがVercelにコードを送る」

**正しい理解:**
「GitHubがVercelに『pushされたよ』と通知  
 → Vercelが自分でGitHubにコードを取りに行く」

**プッシュ型とプル型の組み合わせ:**

```
プッシュ型: GitHub → Vercel 「pushされたよ！」（軽い）
プル型: Vercel → GitHub 「コードちょうだい」（重い）
```

**なぜ2段階？**

**効率性:**
- 通知は小さいデータ（数KB）
- コード全体は大きい（数MB〜数GB）
- 必要な時だけコードを取得

**セキュリティ:**
- Vercelが能動的にコードを取得
- アクセストークンで認証

---

### まとめ

**Webhookの仕組み:**

1. **設定:** GitHubに「pushされたらVercelに教えて」と登録
2. **通知:** git push → GitHub が Vercel に HTTP POST
3. **取得:** Vercel が GitHub からコードを取得
4. **実行:** ビルド・デプロイ

**本質:**
- イベント駆動型プログラミング
- 「何かが起きたら自動で動く」仕組み
- CI/CDの基盤技術

---

## バックエンドの重要性

### フロントエンドとバックエンドの本質的な違い

**フロントエンド:**
- ユーザーのブラウザで動く
- **ユーザーが完全にコントロールできる**
- 開発者ツールで何でも見える・変更できる
- 信用してはいけない領域

**バックエンド:**
- サーバーで動く
- **開発者だけがコントロールできる**
- ユーザーは中身を見られない・変更できない
- 信用できる唯一の領域

---

### セキュリティの鉄則

**「クライアント側（フロント）は一切信用するな」**

どんなに完璧なフロントエンドを作っても、悪意のあるユーザーは:
- HTMLを書き換える
- JavaScriptを無効化する
- 直接APIを叩く
- プログラムで自動攻撃する

**だから、バックエンドで全てチェックする必要がある。**

---

### 具体例: フロントのバリデーションは無意味

#### フロントエンドでのチェック

```typescript
const handleSubmit = () => {
    // メールアドレスの形式チェック
    if (!email.includes('@')) {
        alert('正しいメールアドレスを入力してください');
        return;
    }
    
    // パスワードの長さチェック
    if (password.length < 8) {
        alert('パスワードは8文字以上にしてください');
        return;
    }
    
    // OKなら送信
    fetch('/api/register', {
        method: 'POST',
        body: JSON.stringify({ email, password })
    });
};
```

**これは「ユーザー体験向上」のため。**

でも、悪意のあるユーザーは:

```python
# Python スクリプトで直接APIを叩く
import requests

requests.post('https://example.com/api/register', json={
    'email': 'invalid-email',  # @がなくても送れる
    'password': '123'  # 短くても送れる
})
```

👉 **フロントのチェックは簡単に回避できる**

---

#### バックエンドでのチェック（必須）

```python
from pydantic import BaseModel, EmailStr, validator

class UserRegister(BaseModel):
    email: EmailStr  # 自動でメール形式チェック
    password: str
    
    @validator('password')
    def password_length(cls, v):
        if len(v) < 8:
            raise ValueError('パスワードは8文字以上必要です')
        return v

@app.post("/api/register")
def register(user_data: UserRegister, db: Session = Depends(get_db)):
    # Pydanticが自動でバリデーション
    # 不正なデータは自動で弾かれる
    
    # さらに追加チェック
    existing_user = db.query(User).filter(
        User.email == user_data.email
    ).first()
    
    if existing_user:
        raise HTTPException(
            status_code=400, 
            detail='このメールアドレスは既に使われています'
        )
    
    # パスワードをハッシュ化
    hashed_password = hash_password(user_data.password)
    
    # DBに保存
    new_user = User(
        email=user_data.email, 
        password=hashed_password
    )
    db.add(new_user)
    db.commit()
    
    return {"message": "登録完了"}
```

👉 **どんな方法で送られても、バックエンドで必ずチェックされる**

---

### バックエンドの責任範囲

#### 1. 認証（Authentication）

**「あなたは誰ですか？」**

```python
@app.get("/api/profile")
def get_profile(current_user: User = Depends(get_current_user)):
    # ログインしているユーザーだけアクセス可能
    return current_user
```

---

#### 2. 認可（Authorization）

**「あなたはこれをやっていいですか？」**

```python
@app.delete("/api/users/{user_id}")
def delete_user(
    user_id: int, 
    current_user: User = Depends(get_current_user)
):
    # 管理者だけ実行可能
    if not current_user.is_admin:
        raise HTTPException(
            status_code=403, 
            detail="権限がありません"
        )
    
    # 削除処理
```

---

#### 3. バリデーション（Validation）

**「このデータは正しいですか？」**

```python
class ProjectCreate(BaseModel):
    name: str
    document_url: str
    
    @validator('name')
    def name_not_empty(cls, v):
        if not v.strip():
            raise ValueError('プロジェクト名は必須です')
        return v
    
    @validator('document_url')
    def valid_url(cls, v):
        if not v.startswith('http'):
            raise ValueError('正しいURLを入力してください')
        return v
```

---

#### 4. ビジネスロジック

**「ルールに従っていますか？」**

```python
@app.post("/api/scores")
def create_score(
    score_data: ScoreCreate, 
    db: Session = Depends(get_db)
):
    # メンバーが存在するかチェック
    member = db.query(Member).filter(
        Member.id == score_data.member_id
    ).first()
    
    if not member:
        raise HTTPException(
            status_code=404, 
            detail="メンバーが見つかりません"
        )
    
    # スコアは0-100の範囲かチェック
    if not 0 <= score_data.score <= 100:
        raise HTTPException(
            status_code=400, 
            detail="スコアは0-100の範囲で入力してください"
        )
    
    # 1日1回までチェック
    today = datetime.now().date()
    existing_score = db.query(Score).filter(
        Score.member_id == score_data.member_id,
        Score.created_at >= today
    ).first()
    
    if existing_score:
        raise HTTPException(
            status_code=400, 
            detail="今日はすでにスコアを入力済みです"
        )
    
    # 保存
    new_score = Score(**score_data.dict())
    db.add(new_score)
    db.commit()
    
    return new_score
```

---

#### 5. データ整合性

**「データベースが壊れないようにする」**

```python
@app.delete("/api/projects/{project_id}")
def delete_project(
    project_id: int, 
    db: Session = Depends(get_db)
):
    # プロジェクトを削除する前に、
    # 関連するメンバーとスコアも削除
    
    # まずスコアを削除
    members = db.query(Member).filter(
        Member.project_id == project_id
    ).all()
    
    for member in members:
        db.query(Score).filter(
            Score.member_id == member.id
        ).delete()
    
    # 次にメンバーを削除
    db.query(Member).filter(
        Member.project_id == project_id
    ).delete()
    
    # 最後にプロジェクトを削除
    db.query(Project).filter(
        Project.id == project_id
    ).delete()
    
    db.commit()
    
    return {"message": "削除しました"}
```

---

### フロントとバックの役割分担

| 項目 | フロントエンド | バックエンド |
|------|--------------|------------|
| バリデーション | UX向上（即座にエラー表示） | セキュリティ（必須） |
| 認証 | トークン保存・送信 | トークン検証・発行 |
| 認可 | UIの表示/非表示 | 実際の権限チェック |
| ビジネスロジック | 表示の制御 | ルールの実装 |
| データ整合性 | - | DB整合性の保証 |
| セキュリティ | XSS対策（表示時） | 全ての攻撃対策 |

👉 **バックエンドは「最後の砦」であり、全ての責任を負う**

---

### まとめ

**バックエンドの重要性:**

1. **セキュリティの最後の砦**
   - フロントは信用できない
   - バックエンドで全てチェック

2. **ビジネスロジックの実装場所**
   - ルールの実装
   - データ整合性の保証

3. **パフォーマンスの鍵**
   - N+1問題の解決
   - キャッシュ戦略
   - クエリ最適化

4. **会社の命運を握る**
   - セキュリティ事故は致命傷
   - データ損失は訴訟リスク

**フロントエンドとの違い:**
- フロント = 見た目とUX（信用できない）
- バック = ロジックとセキュリティ（信用の要）

---

## 今後の学習ロードマップ

### 基本方針

**Project Transparencyをベースに実験する**

理由:
- すでに動いている
- リアルな課題から生まれた
- ちょうどいい複雑さ
- Before/After が比較できる

---

### Phase 1: セキュリティ（JWT認証）

**期間:** 2週間

**目標:**  
ユーザー登録・ログイン・認証機能の実装

**やること:**

1. JWTの仕組みを調べる
2. bcryptでパスワードハッシュ化
3. login/registerエンドポイント作成
4. 既存エンドポイントに認証を追加

**確認項目:**
- Postmanでトークン取得できるか
- 認証なしでAPIを叩くとエラーになるか

**追加するテーブル:**

```python
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    name = Column(String, nullable=False)
    created_at = Column(String, default=lambda: datetime.now().isoformat())
```

**新しいエンドポイント:**

```python
@router.post("/api/auth/register")
def register(user_data: UserRegister, db: Session = Depends(get_db)):
    # パスワードをハッシュ化
    # ユーザーを作成
    # トークンを返す
    pass

@router.post("/api/auth/login")
def login(credentials: LoginCredentials, db: Session = Depends(get_db)):
    # メールアドレスとパスワードを検証
    # JWTトークンを発行
    # トークンを返す
    pass
```

**学べること:**
- パスワードのハッシュ化（bcrypt）
- JWTの仕組み
- セキュアなトークン管理
- Dependsの仕組み
- 認証ミドルウェア

---

### Phase 2: パフォーマンス最適化

**期間:** 2週間

**目標:**  
N+1問題の解決、キャッシュ導入

**やること:**

1. 現在のクエリを分析（SQLログを見る）
2. joinedloadで最適化
3. Redisをローカルにセットアップ
4. キャッシュを実装

**確認項目:**
- クエリ数が減ったか（ログで確認）
- レスポンス時間が速くなったか

**N+1問題の解決:**

**Before（悪い例）:**

```python
@router.get("/api/projects/{project_id}/dashboard")
def get_dashboard(project_id: int, db: Session = Depends(get_db)):
    project = db.query(Project).filter(Project.id == project_id).first()
    members = db.query(Member).filter(Member.project_id == project_id).all()
    
    # メンバーごとにスコアを取得（N回クエリ）
    for member in members:
        member.scores = db.query(Score).filter(
            Score.member_id == member.id
        ).all()
    
    return {"project": project, "members": members}
```

実行されるSQL（メンバーが10人いる場合）:

```sql
SELECT * FROM projects WHERE id = 1;          -- 1回目
SELECT * FROM members WHERE project_id = 1;   -- 2回目
SELECT * FROM scores WHERE member_id = 1;     -- 3回目
SELECT * FROM scores WHERE member_id = 2;     -- 4回目
...
SELECT * FROM scores WHERE member_id = 10;    -- 12回目
```

👉 **合計12回のクエリ**

**After（良い例）:**

```python
from sqlalchemy.orm import joinedload

@router.get("/api/projects/{project_id}/dashboard")
def get_dashboard(project_id: int, db: Session = Depends(get_db)):
    project = db.query(Project).options(
        joinedload(Project.members).joinedload(Member.scores)
    ).filter(Project.id == project_id).first()
    
    return {"project": project, "members": project.members}
```

実行されるSQL:

```sql
SELECT * FROM projects
LEFT JOIN members ON projects.id = members.project_id
LEFT JOIN scores ON members.id = scores.member_id
WHERE projects.id = 1;
```

👉 **1回のクエリで全てのデータを取得**

**キャッシュの導入:**

```python
import redis

redis_client = redis.Redis(host='localhost', port=6379)

@router.get("/api/projects/{project_id}/dashboard")
def get_dashboard(project_id: int, db: Session = Depends(get_db)):
    # キャッシュをチェック
    cache_key = f"dashboard:{project_id}"
    cached_data = redis_client.get(cache_key)
    
    if cached_data:
        return json.loads(cached_data)
    
    # キャッシュがなければDBから取得
    data = fetch_dashboard_data(project_id, db)
    
    # キャッシュに保存（5分間）
    redis_client.setex(cache_key, 300, json.dumps(data))
    
    return data
```

**学べること:**
- JOINの使い方
- Eager Loading vs Lazy Loading
- SQLAlchemyの最適化
- Redisの使い方
- キャッシュ戦略
- TTL（Time To Live）

---

### Phase 3: テスト駆動開発（TDD）

**期間:** 2週間

**目標:**  
テストカバレッジ80%以上

**やること:**

1. pytestセットアップ
2. 既存機能のテストを書く
3. 新機能をTDDで実装

**確認項目:**
- pytestでテストが通るか
- カバレッジレポート

**ユニットテスト:**

```python
# tests/test_dashboard.py
import pytest
from app.routers.dashboard import calculate_weighted_average

def test_calculate_weighted_average():
    # テストデータ
    members_with_scores = [
        {"role": "PL", "latest_score": 80},
        {"role": "PM", "latest_score": 90},
        {"role": "Member", "latest_score": 70},
    ]
    
    # 期待値: (80*3 + 90*2 + 70*1) / (3+2+1) = 80
    result = calculate_weighted_average(members_with_scores)
    
    assert result == 80.0
```

**統合テスト:**

```python
# tests/test_api.py
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_project():
    response = client.post("/api/projects", json={
        "name": "テストプロジェクト",
        "document_url": "https://example.com"
    })
    
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "テストプロジェクト"
    assert "id" in data
```

**TDDのサイクル:**

1. **Red:** テストを先に書く（失敗する）
2. **Green:** 実装する（テストが通る）
3. **Refactor:** リファクタリング（改善）

**学べること:**
- pytestの使い方
- テストケースの設計
- エッジケースの考え方
- TestClientの使い方
- モックの使い方
- TDDのサイクル
- 安全なリファクタリング

---

### 学習の進め方（推奨）

#### Week 1-2: JWT認証

**目標:** ユーザー登録・ログイン・認証機能の実装

**Day 1-2:** JWTの仕組みを学ぶ
**Day 3-4:** bcryptでパスワードハッシュ化
**Day 5-7:** login/registerエンドポイント作成
**Day 8-10:** 既存エンドポイントに認証を追加
**Day 11-14:** テストと改善

#### Week 3-4: パフォーマンス最適化

**目標:** N+1問題の解決、キャッシュ導入

**Day 1-3:** 現在のクエリを分析
**Day 4-7:** joinedloadで最適化
**Day 8-10:** Redisセットアップ
**Day 11-14:** キャッシュ実装とテスト

#### Week 5-6: テスト駆動開発

**目標:** テストカバレッジ80%以上

**Day 1-3:** pytestセットアップ
**Day 4-10:** 既存機能のテストを書く
**Day 11-14:** 新機能をTDDで実装

---

### 実験のアイデア

#### 実験1: セキュリティ

**Before:** 認証なし → 誰でもアクセス可能

**After:** JWT認証 → トークンがないとアクセス不可

**測定:**
- Postmanで試す
- 悪意のあるリクエストを送ってみる

---

#### 実験2: パフォーマンス

**Before:** N+1問題あり

**After:** joinedloadで最適化

**測定:**
- SQLログでクエリ数を比較
- レスポンス時間を測定（Postman）
- 10人のメンバーがいるプロジェクト vs 100人

---

#### 実験3: テスト

**Before:** テストなし → リファクタリングが怖い

**After:** テストあり → 安心してリファクタリング

**測定:**
- テストカバレッジ
- バグの発見数

---

### 最終的な姿

**Project Transparency v2.0:**

✅ ユーザー認証（JWT）  
✅ 権限管理（RBAC）  
✅ パフォーマンス最適化（N+1解決、キャッシュ）  
✅ テストカバレッジ 80%以上  
✅ CI/CD（テスト自動実行）

**これができたら:**
- 実務で即戦力
- ポートフォリオとして強力
- 面接で語れる深い経験

---

## 総括

### 今回の会話で理解したこと

**技術的理解:**

1. **デプロイ・ビルド・CI/CDの違い**
   - ビルド = 変換・最適化
   - デプロイ = 公開
   - CI/CD = 自動化

2. **SQLAlchemyのデータベース抽象化**
   - ORMレイヤーでSQL方言を吸収
   - 同じコードで複数のDBをサポート
   - 環境変数で切り替え

3. **フロントとバックの分離理由**
   - セキュリティ
   - バリデーション
   - 独立性
   - スケーラビリティ
   - チーム開発

4. **GitHubとプロダクション環境の連携**
   - Webhookの仕組み
   - 自動デプロイの流れ
   - CI/CDパイプライン

5. **バックエンドの重要性**
   - 最後の砦
   - 全ての責任を負う
   - フロントは信用できない

---

### 次のアクション

**短期（2週間）:**
- JWT認証の実装

**中期（1ヶ月）:**
- パフォーマンス最適化

**長期（2ヶ月）:**
- テスト駆動開発

**最終目標:**
- Project Transparency v2.0の完成
- Zoffで活躍できるスキルの習得

---

**作成日:** 2025-11-09  
**バージョン:** 1.0
