# Project Transparency - 開発の学びと振り返り

## 概要

このドキュメントは、Project Transparencyの開発プロセスを通じて得られた学びと気づきを記録したものです。

---

## 開発期間

- **期間**: 2025年11月7日〜11月9日（約3日間）
- **開発形態**: AI（Claude）との協働開発
- **成果物**: フルスタックWebアプリケーション + 本番環境デプロイ

---

## プロジェクトの進め方

### 1. 課題発見フェーズ

**アプローチ:**
- 自身の業務経験（Rakutenでの引き継ぎ業務）から課題を抽出
- 「何が書かれていないか、誰も分からない」という本質的な問題を特定

**学び:**
- 課題の「本質」を言語化することの重要性
- 表面的な問題（「ドキュメントがない」）ではなく、深層の問題（「何が足りないか分からない」）を見抜く
- 自分の経験を抽象化して、普遍的な課題として再定義する力

---

### 2. 設計フェーズ

**アプローチ:**
- DB設計 → API設計 → ディレクトリ構成の順で段階的に設計
- 各段階で対話を通じて要件を明確化
- ドキュメントとして設計を残す（`design/`ディレクトリ）

**学び:**

#### 「設計」と「実装」を分離する価値
- 設計時は「何を作るか」に集中
- 実装時は「どう作るか」に集中
- 混ぜると両方が中途半端になる

#### ドキュメント駆動開発の有効性
- DB設計、API設計をMarkdown/SQLで明文化
- これがClaude Codeへの「実装指示書」になる
- 後から見返せる、他の人にも伝わる

#### 対話を通じた要件の精緻化
- 例：「メンバー削除は必要？」→「MVPでは不要」
- 例：「プロジェクト一覧は必要？」→「必要、UIのイメージがある」
- 曖昧な要件を具体化していくプロセスが重要

---

### 3. 実装フェーズ

**アプローチ:**
- `IMPLEMENTATION_GUIDE.md`を作成してClaude Codeに渡す
- Claude Codeが自律的に実装
- 実装の質を確認し、必要に応じて調整

**学び:**

#### AIを「指示する側」に回る重要性
- 「コード書いて」ではなく「この設計に従って実装して」
- 明確な指示書があれば、AIは驚くほど正確に実装する
- PMやテックリードの視点で開発を進める

#### 実装の質が予想以上に高い
- TypeScriptの型定義が完璧
- エラーハンドリングも適切
- ディレクトリ構成もベストプラクティスに準拠
- `lib/api.ts`でAPI呼び出しを集約（DRY原則）

#### AIが「なぜそうするのか」を理解している
- 単なるコピペではなく、設計意図を理解した実装
- 例：役職の重み付けロジックを正確に実装
- 例：CORS設定を本番環境に対応させる

---

### 4. デプロイフェーズ

**アプローチ:**
- バックエンド（Render）→ フロントエンド（Vercel）の順でデプロイ
- Claude Code + Render MCPを使った自動化

**学び:**

#### CI/CDの威力を体感
- GitHubにpushするだけで自動デプロイ
- 従来の手動デプロイ（47分）→ AI自動化（2分）
- 約23倍の効率化

#### 「デプロイ」の本質理解
- フロント・バックを分けてデプロイする理由
  - それぞれに最適化されたプラットフォーム
  - Vercel: Next.js専用、CDN自動配信、爆速
  - Render: API専用、Postgres対応
- 環境変数の役割
  - `NEXT_PUBLIC_API_BASE_URL`: フロントがバックを探す
  - `DATABASE_URL`: バックがDBに接続する
- エンドポイント設定の意味
  - URLが変わるだけで、ローカルと本質的に同じ
  - ハードコーディングを避ける重要性

#### トラブルシューティングから学ぶ
- Pydanticのビルドエラー → requirements.txt更新
- SSL接続エラー → 別アプローチに切り替え
- エラーが出ても、AIが自動で代替案を試す
- 人間のように「Plan B」を考える

---

### 5. AI活用フェーズ

**アプローチ:**
- Claude（対話型）: 設計・意思決定
- Claude Code（自律型）: 実装
- Render MCP: インフラ操作

**学び:**

#### AIの役割分担が明確
```
Claude（対話型）:
- 戦略的思考
- 課題の本質を見抜く
- 設計の意思決定
- ドキュメント作成

Claude Code（自律型）:
- コード実装
- Git操作
- ファイル管理
- 自律的な判断

Render MCP:
- インフラ構築
- DB作成
- 環境変数設定
- サービス管理
```

#### AI活用の本質
- **「教える」から「やる」へ**
  - 従来: 「どうやればいい？」→ AIが説明 → 人間が実行
  - 今: 「やって」→ AIが実行 → 完了
  
- **自動化の究極形**
  - Rakutenでの業務自動化: Excel作業（3時間）→ Python（5分）
  - 今回の開発: DB移行+デプロイ（47分）→ AI（2分）
  - 本質は同じ：「面倒な作業を自動化」

#### 「AIを使いこなす」とは
- AIに丸投げするのではない
- **方向性を決めるのは人間**
- **実行するのはAI**
- 完全に「設計者・PMの視点」

---

## 技術的な学び

### 1. フルスタック開発の全体像

**バックエンド:**
- FastAPI: Pythonの高速Webフレームワーク
- SQLAlchemy: ORM（Object-Relational Mapping）
- Pydantic: バリデーション
- PostgreSQL: 本番環境のDB

**フロントエンド:**
- Next.js 14 (App Router): React フレームワーク
- TypeScript: 型安全性
- Tailwind CSS: ユーティリティファースト CSS
- Recharts: グラフ描画

**インフラ:**
- Render: バックエンドホスティング
- Vercel: フロントエンドホスティング
- GitHub: バージョン管理 + CI/CD

---

### 2. 設計パターンの理解

#### DRY原則（Don't Repeat Yourself）
- `lib/api.ts`でAPI呼び出しを一箇所に集約
- ハードコーディングを避ける
- 変更が1箇所で済む

#### Single Source of Truth
- APIのベースURLは環境変数で管理
- 本番とローカルで自動切り替え
- `process.env.NEXT_PUBLIC_API_BASE_URL`

#### 関心の分離
- フロントエンド: UI/UX
- バックエンド: ビジネスロジック
- データベース: データ永続化

---

### 3. 加重平均の実装

**数式:**
```
加重平均 = Σ(スコア × 重み) / Σ(重み)

重み:
- PL: 3
- PM: 2
- Member: 1
```

**実装:**
```python
def calculate_weighted_average(members_with_scores):
    weighted_sum = 0
    total_weight = 0
    
    for member in members_with_scores:
        if member["latest_score"] is not None:
            weight = ROLE_WEIGHTS.get(member["role"], 1)
            weighted_sum += member["latest_score"] * weight
            total_weight += weight
    
    return round(weighted_sum / total_weight, 1) if total_weight > 0 else 0
```

**学び:**
- 経験値の違いを定量化
- シンプルだが効果的なロジック
- ビジネスルールをコードで表現

---

### 4. データベース設計の原則

**正規化:**
- projects ← members ← scores
- 1対多の関係を正しくモデリング
- ON DELETE CASCADEで整合性確保

**履歴の保存:**
- スコアは上書きではなく追加
- 時系列データとして全て保存
- 推移を可視化できる

**インデックス:**
- `idx_members_project_id`
- `idx_scores_member_id`
- `idx_scores_created_at`
- 検索パフォーマンスを最適化

---

## プロセスの学び

### 1. 効率的な開発プロセス

```
従来のウォーターフォール:
要件定義 → 設計 → 実装 → テスト → デプロイ
（各フェーズが長い）

今回のプロセス:
課題発見 → 設計（1日） → 実装（AI・数時間） → デプロイ（AI・数分）
（圧倒的に速い）
```

**成功要因:**
- 設計を先に固める
- ドキュメント化する
- AIに明確な指示を出す
- 段階的に進める

---

### 2. 対話を通じた学習

**例1: `lib`ディレクトリの意味**
- 質問: 「libってどういう意味？」
- 回答: library（ライブラリ）の略、共通ロジックを格納
- 学び: ハードコーディングを避ける理由

**例2: デプロイの仕組み**
- 質問: 「なんでバックエンドとフロントエンドでデプロイする場所を変える必要があるの？」
- 回答: 分ける必要はないが、それぞれに最適化されたプラットフォームを使う方が効率的
- 学び: 技術選定の背景にある理由

**例3: 認証の必要性**
- 質問: 「認証機能はつけてないじゃん？誰でもデータを入れられる？」
- 回答: そうです、MVPとしてはこれでOK
- 学び: スコープを適切に絞る重要性

---

### 3. メタ認知の重要性

**自分の学習プロセスを客観視:**
- 「めっちゃ賢いやり方じゃない？」
- 「僕ってAI使いこなしてるよね？」

**これができる人は強い:**
- 自分のやり方を分析できる
- 改善点が見える
- 他の人に説明できる

---

## ビジネスの学び

### 1. MVPの重要性

**MVPで実装したもの:**
- プロジェクト作成
- メンバー登録（役職付き）
- スコアリング
- ダッシュボード（加重平均、推移）

**MVPで実装しなかったもの:**
- ユーザー認証
- メンバー削除
- プロジェクト編集・削除
- 通知機能
- エクスポート機能

**学び:**
- 最小限の機能で価値を証明
- 完璧を目指さない
- フィードバックを得てから拡張

---

### 2. 課題の本質を捉える

**表面的な課題:**
- 「ドキュメントがない」
- 「引き継ぎが大変」

**本質的な課題:**
- 「何が書かれていないか、誰も分からない」
- 「認識のズレが可視化されていない」

**学び:**
- Why を5回繰り返す
- 一次情報（自分の経験）から考える
- 既存ツールの「限界」を見抜く

---

### 3. ポジショニング

**当初:**
「引き継ぎを効率化するツール」
→ 誰も使わない（今困ってないから）

**改善:**
「プロジェクトの透明性を高め、組織の健全性を測るツール」
→ 日常的に使う価値

**学び:**
- ネガティブな言葉（退職、引き継ぎ）を避ける
- ポジティブな価値提案
- 継続的に使える理由を作る

---

## 哲学的な学び

### タレブの「退職届を机の中に」

**洞察:**
- いつでも辞められると分かると、プレッシャーから解放される
- 今日という日が「義務」から「選択」に変わる
- 心理的な余裕が生まれる

**逆説:**
- **いつでも辞められるからこそ、辞めなくなる**
- 逃げ道があるから、リスクを取れる
- 自由があるから、自由に縛られなくなる

**プロダクトへの応用:**
- 「いつでも引き継げる状態」を日常的に維持
- これが組織の健全性につながる
- 透明性が自由を生む

---

## 今後の展開

### Phase 2以降の機能拡張案

**技術的拡張:**
- Slack/Teams連携（通知）
- AIによるドキュメント分析
- 他プロジェクトとのベンチマーク

**ビジネス的拡張:**
- 企業向けSaaS化
- 従業員数課金 or プロジェクト数課金
- HR Tech / Productivity Tools として展開

---

## 結論

### 最も重要な学び

**1. 設計と実装の分離**
- 「何を作るか」と「どう作るか」を分ける
- ドキュメント駆動開発の威力

**2. AIを「指示する側」に回る**
- 方向性を決めるのは人間
- 実行するのはAI
- PM/テックリードの視点

**3. 本質を捉える力**
- 表面的な課題ではなく、深層の問題を見抜く
- Why を繰り返す
- 自分の経験を抽象化する

**4. 効率化の本質**
- Rakutenでの業務自動化: Excel → Python
- 今回の開発: 手動デプロイ → AI自動化
- 「面倒な作業を自動化」は普遍的

**5. メタ認知**
- 自分の学習プロセスを客観視
- 「AI使いこなしてる？」と問える
- 改善点が見える

---

## Tech0での発表に向けて

### 伝えたいメッセージ

**技術的側面:**
- フルスタックで実際に動くものを作った
- AI（Claude Code）を活用した効率的な開発
- 設計 → 実装 → デプロイの全プロセス

**ビジネス的側面:**
- 自分の経験から課題を発見
- 既存ツールの限界を見抜く
- シンプルだが本質的なソリューション

**哲学的側面:**
- 「いつでも辞められる自由」が組織を健全にする
- タレブの洞察を実践
- 逆説的だが真実

---

## 振り返って

この3日間で：
- フルスタックアプリを完成させた
- 本番環境にデプロイした
- AIとの協働開発を体験した
- 設計の重要性を実感した
- 自分の強みを再確認した

**何より:**
- 「AI使いこなしてる」と自信を持って言える
- 設計者・PMとしての視点を持てた
- メタ認知ができている

**Tech0での発表が楽しみ！**
